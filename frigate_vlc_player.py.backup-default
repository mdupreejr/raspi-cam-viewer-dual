#!/usr/bin/env python3

import os
import sys
import subprocess
import signal
import json
import time
import logging
import re

try:
    import paho.mqtt.client as mqtt
except ImportError:
    print("Installing required package: paho-mqtt...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "paho-mqtt"])
    import paho.mqtt.client as mqtt

# Configuration
MQTT_HOST = os.environ.get("FRIGATE_MQTT_HOST", "fl7")
MQTT_PORT = int(os.environ.get("FRIGATE_MQTT_PORT", "1883"))
MQTT_TOPIC = os.environ.get("FRIGATE_MQTT_TOPIC", "frigate/events")
RTSP_BASE = os.environ.get("FRIGATE_RTSP_BASE", f"rtsp://{MQTT_HOST}:8554")
VLC_DISPLAY = os.environ.get("DISPLAY", ":0")

DETECTION_PRIORITIES = {
    "person": 10,
    "dog": 8,
    "cat": 7,
    "bird": 6,
    "car": 5,
    "motorcycle": 4,
    "bicycle": 3,
    "default": 1
}

IGNORED_CAMERAS_FILE = os.path.expanduser("~/Desktop/ignored_cameras.txt")
PRIORITIES_FILE = os.path.expanduser("~/Desktop/detection_priorities.txt")
LOG_FILE = os.path.expanduser("~/vlc_activity.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler(LOG_FILE)]
)
logger = logging.getLogger(__name__)

class FrigateVLCPlayer:
    def __init__(self):
        self.mqtt_client = mqtt.Client()
        self.vlc_process = None
        self.current_camera = None
        self.current_priority = 0
        self.ignored_cameras = set()
        self.load_ignored_cameras()
        self.load_priorities()
        
    def load_ignored_cameras(self):
        self.ignored_cameras = set()
        if os.path.exists(IGNORED_CAMERAS_FILE):
            try:
                with open(IGNORED_CAMERAS_FILE, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            self.ignored_cameras.add(line.lower())
                if self.ignored_cameras:
                    logger.info(f"Loaded ignored cameras: {', '.join(sorted(self.ignored_cameras))}")
            except Exception as e:
                logger.warning(f"Could not load ignored cameras file: {e}")
        
    def load_priorities(self):
        global DETECTION_PRIORITIES
        if os.path.exists(PRIORITIES_FILE):
            try:
                with open(PRIORITIES_FILE, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#') and '=' in line:
                            label, priority = line.split('=', 1)
                            try:
                                DETECTION_PRIORITIES[label.strip().lower()] = int(priority.strip())
                            except ValueError:
                                pass
            except Exception as e:
                logger.warning(f"Could not load priorities file: {e}")
    
    def on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            logger.info(f"Connected to MQTT broker at {MQTT_HOST}:{MQTT_PORT}")
            client.subscribe(MQTT_TOPIC)
            logger.info(f"Subscribed to topic: {MQTT_TOPIC}")
        else:
            logger.error(f"Failed to connect to MQTT broker. Code: {rc}")
    
    def on_disconnect(self, client, userdata, rc):
        if rc != 0:
            logger.warning(f"Unexpected MQTT disconnection. Code: {rc}")
            logger.info("Attempting to reconnect...")
    
    def on_message(self, client, userdata, msg):
        try:
            data = json.loads(msg.payload.decode())
            
            if data.get('type') != 'new':
                return
            
            after = data.get('after', {})
            camera = after.get('camera')
            label = after.get('label', 'unknown')
            
            if not camera:
                logger.warning("No camera found in event data")
                return
            
            if camera.lower() in self.ignored_cameras:
                logger.info(f"Ignoring detection on camera '{camera}' (in ignore list)")
                return
            
            priority = DETECTION_PRIORITIES.get(label.lower(), DETECTION_PRIORITIES.get('default', 1))
            logger.info(f"New detection: {label} on camera '{camera}'")
            self.play_camera(camera, priority)
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse MQTT message: {e}")
        except Exception as e:
            logger.error(f"Error processing MQTT message: {e}")
    
    def format_camera_for_rtsp(self, camera_name):
        # Special case for GL-FrontDoor -> gr_frontdoor
        if camera_name.lower() == 'gl-frontdoor':
            return 'gr_frontdoor'
        formatted = camera_name.replace('-', '_').lower()
        return formatted
    
    def play_camera(self, camera, priority=1):
        if self.current_camera == camera:
            logger.info(f"Camera '{camera}' is already playing")
            return
            
        rtsp_camera = self.format_camera_for_rtsp(camera)
        rtsp_url = f"{RTSP_BASE}/{rtsp_camera}"
        logger.info(f"Playing stream: {rtsp_url} (from camera: {camera})")
        
        self.stop_vlc()
        
        try:
            # Use optimized settings for Pi 5
            vlc_cmd = [
                "cvlc",
                "--fullscreen",
                "--loop",
                "--no-video-title-show",
                "--network-caching=1000",
                "--file-caching=1000",
                "--live-caching=1000",
                "--clock-jitter=0",
                "--drop-late-frames",
                "--skip-frames",
                rtsp_url
            ]
            
            env = os.environ.copy()
            env["DISPLAY"] = VLC_DISPLAY
            
            self.vlc_process = subprocess.Popen(
                vlc_cmd,
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            self.current_camera = camera
            self.current_priority = priority
            logger.info(f"VLC started for camera '{camera}' (PID: {self.vlc_process.pid})")
            
        except Exception as e:
            logger.error(f"Failed to start VLC: {e}")
            self.vlc_process = None
            self.current_camera = None
    
    def stop_vlc(self):
        if self.vlc_process and self.vlc_process.poll() is None:
            logger.info(f"Stopping VLC (PID: {self.vlc_process.pid})")
            try:
                self.vlc_process.terminate()
                self.vlc_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("VLC did not terminate, forcing kill")
                self.vlc_process.kill()
                self.vlc_process.wait()
            self.vlc_process = None
            self.current_camera = None
            self.current_priority = 0
    
    def run(self):
        logger.info("=== Frigate VLC Player Starting ===")
        logger.info(f"MQTT Broker: {MQTT_HOST}:{MQTT_PORT}")
        logger.info(f"MQTT Topic: {MQTT_TOPIC}")
        logger.info(f"RTSP Base: {RTSP_BASE}")
        logger.info(f"Display: {VLC_DISPLAY}")
        logger.info(f"Ignored Cameras File: {IGNORED_CAMERAS_FILE}")
        logger.info("===================================")
        
        self.mqtt_client.on_connect = self.on_connect
        self.mqtt_client.on_disconnect = self.on_disconnect
        self.mqtt_client.on_message = self.on_message
        
        logger.info(f"Connecting to MQTT broker at {MQTT_HOST}:{MQTT_PORT}")
        self.mqtt_client.connect(MQTT_HOST, MQTT_PORT, 60)
        self.mqtt_client.loop_forever()
    
    def cleanup(self):
        logger.info("Cleaning up...")
        self.stop_vlc()
        if self.mqtt_client:
            self.mqtt_client.disconnect()
        logger.info("Cleanup complete")

def signal_handler(signum, frame):
    logger.info(f"Received signal {signum}")
    if 'player' in globals():
        player.cleanup()
    sys.exit(0)

if __name__ == "__main__":
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    player = FrigateVLCPlayer()
    
    try:
        player.run()
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
    except Exception as e:
        logger.error(f"Error in main loop: {e}")
    finally:
        player.cleanup()
